import re
import sys
from pathlib import Path

from sqlalchemy import create_engine, select
from sqlalchemy.orm import *
from tqdm import tqdm

from zotero_sqlite_models import Item

path_zotero_sqlite = Path('/Users/tom/Main/Zotero/zotero.sqlite')
dir_obsidian_papers = Path('/Users/tom/Main/notes/Papers')

KEY_TITLE = 'title'
KEY_ABSTRACT_NOTE = 'abstractNote'
KEY_DATE = 'date'
KEY_EXTRA = 'extra'

META_BLACKLIST_KEYS = [
    KEY_ABSTRACT_NOTE
]

MANUALLY_SORTED_KEYS = [
    KEY_TITLE,
    'zoteroLink',
    'date',
    'creators',
]

LIBRARY_ID = 1

BLOCK_START = '%% AUTO GENERATED BY zotero_to_obsidian.py START %%'
BLOCK_END = '%% AUTO GENERATED BY zotero_to_obsidian.py END %%'


def parse_date(raw_date):
    match = re.match(r'^(\d\d\d\d)-(\d\d)-(\d\d) .*$', raw_date)
    year_str = match.group(1)
    month_str = match.group(2)
    day_str = match.group(3)

    # because sometimes it is sth like "2022-00-00"
    if int(month_str) == 0:
        month_str = '01'
    if int(day_str) == 0:
        day_str = '01'

    return f'{year_str}-{month_str}-{day_str}'


def parse_extra(raw: str):
    ans = {}
    unknown_count = 0
    for line in raw.split('\n'):
        try:
            idx = line.index(':')
            ans[line[:idx].strip()] = line[idx + 1:].strip()
        except ValueError:
            ans[f'unknown_{unknown_count}'] = line
            unknown_count += 1
    return ans


def parse(obj):
    if len(obj.attachments) > 0 or len(obj.annotations) > 0 or len(obj.notes) > 0:
        return None

    all_fields = {item.field.fieldName: item.value.value for item in obj.itemData}

    parsed_extra = parse_extra(all_fields[KEY_EXTRA]) if KEY_EXTRA in all_fields else {}

    if KEY_TITLE not in all_fields:
        return None

    zotero_link = f'zotero://select/items/{LIBRARY_ID}_{obj.key}'

    info = {
        'key': obj.key,
        'zoteroLink': f'[{zotero_link}]({zotero_link})',
        'dateAdded': obj.dateAdded,
        'creators': ' ; '.join(
            f'[[{creator.firstName}, {creator.lastName}]]'
            for creator in obj.creators
        ),
        **{k: v for k, v in all_fields.items() if k != KEY_EXTRA},
        **parsed_extra,
        # override the all_fields's date, so put it below
        'date': parse_date(all_fields[KEY_DATE]) if KEY_DATE in all_fields else '',
    }
    # print(info)

    return info


def calc_filename(info):
    # "better bibtex" will save that in "extra" field
    return info['Citation Key'] + '.md'
    # sanitized_title = info[KEY_TITLE] \
    #     .replace('/', ' ') \
    #     .replace('\\', ' ') \
    #     .replace(':', ' ')
    # return f'{sanitized_title}.md'


def format_meta(info):
    def format_one_key(k):
        return f'**{k}**:: {info[k]}'

    lines = []

    for key in MANUALLY_SORTED_KEYS:
        if key in info:
            lines.append(format_one_key(key))
    for key in info.keys():
        if key not in MANUALLY_SORTED_KEYS and key not in META_BLACKLIST_KEYS:
            lines.append(format_one_key(key))

    return '\n'.join(lines)


def calc_default_full_text(obj, info):
    status = 'unread'
    area = 'unclassified'

    # # NOTE only for temporary migration!
    # # the values are created by looking at `collections` table manually
    # collection_id = obj.collections[0].collectionID if len(obj.collections) > 0 else None
    # if collection_id in [11, 8]:
    #     area = sys.argv[1]
    # elif collection_id in [16]:
    #     area = f'{sys.argv[1]}-related'
    # else:
    #     status = 'done'
    #     area = 'misc'

    return f'''---
tags:
  - area/{area}
---

**status**:: {status}

**rating**:: ‚≠ê

**summary**:: 

---

## Analysis

N/A

---

{BLOCK_START}
/* nothing */
{BLOCK_END}
'''


def calc_block_output(info):
    return f'''
## Metadata

{format_meta(info)}

## Abstract

{info.get(KEY_ABSTRACT_NOTE) or 'N/A'}
'''


def calc_output(block_output, old_text):
    old_lines = old_text.split('\n')

    idx_start = old_lines.index(BLOCK_START)
    idx_end = old_lines.index(BLOCK_END)

    return '\n'.join([
        *old_lines[:idx_start + 1],
        *block_output.split('\n'),
        *old_lines[idx_end:],
    ])


# ref
# https://www.zotero.org/support/dev/client_coding/direct_sqlite_database_access
# https://github.com/zotero/zotero-schema/tree/master
def main():
    assert Path(path_zotero_sqlite).exists()
    engine = create_engine(f"sqlite:///{path_zotero_sqlite}", echo=False)
    session = Session(engine)

    stmt = select(Item)

    for obj in tqdm(list(session.scalars(stmt))):
        info = parse(obj)
        if info is None:
            continue

        filename = calc_filename(info)
        path_output = dir_obsidian_papers / filename
        old_text = path_output.read_text() if path_output.exists() else calc_default_full_text(obj, info)
        block_output = calc_block_output(info)

        # print(f'Output: {path_output}')
        path_output.write_text(calc_output(block_output, old_text))


if __name__ == '__main__':
    main()
